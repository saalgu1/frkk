
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>AR Free Kick - Arcade Mode</title>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Teko:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0; overflow: hidden;
            background-color: #1a1a2e;
            font-family: 'Teko', sans-serif;
            user-select: none; -webkit-user-select: none;
        }

        #game-container {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1;
        }

        #input-video {
            position: absolute; top: 0; left: 0; width: 320px; height: 240px;
            transform: scaleX(-1); opacity: 0; pointer-events: none; z-index: 0;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            transition: all 0.5s;
        }

        #ui-layer.game-active .hud-top {
            transform: scale(1.4); transform-origin: top center; margin-top: 10px;
        }

        .hud-top {
            padding: 20px; display: flex; justify-content: space-between; color: white; text-transform: uppercase;
            text-shadow: 0 0 10px rgba(0,0,0,0.8); transition: transform 0.5s; width: 100%; box-sizing: border-box;
        }

        .score-box {
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(0,0,0,0.4)); 
            padding: 10px 25px; border-radius: 8px;
            border-left: 5px solid #2ecc71; font-size: 32px; letter-spacing: 2px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        /* NEW: Side Bars for Aiming Feedback */
        #aim-hud-left, #aim-hud-right {
            position: absolute; top: 50%; width: 20px; height: 200px;
            background: rgba(0,0,0,0.5); border: 2px solid white; border-radius: 10px;
            transform: translateY(-50%); display: none;
        }
        #aim-hud-left { left: 20px; }
        #aim-hud-right { right: 20px; }
        
        .aim-indicator {
            width: 100%; height: 20%; background: #f1c40f;
            position: absolute; top: 50%; transition: top 0.2s;
            box-shadow: 0 0 10px #f1c40f;
        }

        .center-card {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95); padding: 40px; border-radius: 12px;
            text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.6);
            pointer-events: auto; width: 90%; max-width: 420px;
            transition: opacity 0.3s;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .hidden { opacity: 0; pointer-events: none; }

        h1 { margin: 0; color: #2c3e50; font-size: 56px; line-height: 0.9; letter-spacing: 1px; }
        p { font-family: sans-serif; color: #7f8c8d; margin-bottom: 24px; font-size: 16px; line-height: 1.5; }

        button {
            background: linear-gradient(to right, #e74c3c, #c0392b); 
            color: white; border: none; padding: 16px 40px; border-radius: 30px;
            font-size: 28px; font-family: 'Teko', sans-serif;
            cursor: pointer; text-transform: uppercase; letter-spacing: 2px; width: 100%;
            transition: transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 10px 20px rgba(231, 76, 60, 0.3);
        }
        button:disabled { background: #bdc3c7; cursor: wait; box-shadow: none; }

        #setup-overlay {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: white; text-shadow: 0 2px 20px rgba(0,0,0,0.8);
            display: none; width: 100%; z-index: 50;
        }
        #setup-msg { font-size: 60px; color: #f1c40f; font-weight: 600; white-space: nowrap; }
        #countdown-txt { font-size: 200px; font-weight: bold; display: none; margin-top: -20px; color: white;}

        #guide-reticle {
            position: absolute; top: 50%; left: 50%;
            width: 300px; height: 500px;
            transform: translate(-50%, -45%);
            border: 8px dashed #00ffff; border-radius: 30px;
            box-sizing: border-box; pointer-events: none;
            display: none; transition: all 0.3s; z-index: 40;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }
        #guide-status {
            position: absolute; bottom: 20px; width: 100%; 
            text-align: center; font-size: 48px; color: white;
            text-shadow: 0 2px 10px black; font-weight: bold;
        }

        #kick-feedback {
            position: absolute; top: 30%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 110px; color: #fff;
            text-shadow: 0 0 20px #f1c40f, 6px 6px 0 #c0392b;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none; white-space: nowrap; text-align: center; z-index: 20;
        }
        #aim-arrow-txt { font-size: 60px; display: block; margin-top: 5px; color: #f1c40f; text-shadow: 2px 2px 0 #000; }

        #game-container::after {
            content: " ";
            display: block; position: absolute; top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 4px; z-index: 2; pointer-events: none;
        }
        
        #controls-hint {
            position: absolute; bottom: 10%; width: 100%; text-align: center;
            color: rgba(255,255,255,0.8); font-size: 24px; display: none;
            text-shadow: 0 2px 4px black; letter-spacing: 1px;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <video id="input-video" playsinline></video>
    <div id="game-container"></div>
    
    <div id="kick-feedback">
        <span id="feedback-text">GOAL!!!</span>
        <div id="aim-arrow-txt"></div>
    </div>
    
    <div id="aim-hud-left"><div class="aim-indicator" id="aim-y-ind"></div></div>
    
    <div id="guide-reticle">
        <div id="guide-status">Adjusting...</div>
    </div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-box">GOALS: <span id="score-val">0</span></div>
            <div class="score-box" style="border-left:none; border-right: 5px solid #3498db">
                SPEED: <span id="speed-val">0</span> km/h
            </div>
        </div>

        <div id="controls-hint">STEP LEFT/RIGHT TO AIM &bull; SWING TO KICK</div>

        <div id="start-screen" class="center-card">
            <h1>FREE KICK PRO</h1>
            <p style="font-size: 60px; margin: 10px;">âš½</p>
            <p><strong>NEW CONTROLS:</strong><br>1. Step Side-to-Side to Aim Arrow<br>2. Step Back for High Shots<br>3. Swing Foot to Kick</p>
            <button id="start-btn" disabled>Loading Engine...</button>
        </div>

        <div id="setup-overlay">
            <div id="setup-msg"></div>
            <div id="countdown-txt">3</div>
        </div>
    </div>

    <script>
        /**
         * FREE KICK PRO - ARCADE UPDATE
         * Body-Based Aiming System
         */

        const CONFIG = {
            kickThreshold: 2.5, // Speed required to trigger kick
            goalWidth: 14,
            goalHeight: 7,
            goalZ: -24,
            wallZ: -14,
        };

        let state = {
            phase: 'MENU', 
            score: 0,
            ballState: 'IDLE',
            velocity: new THREE.Vector3(),
            leftFoot: {x: 0, y: 0, vx: 0, vy: 0},
            rightFoot: {x: 0, y: 0, vx: 0, vy: 0},
            playerScale: 1.0, 
            hipCenter: {x: 0.5, y: 0.5},
            setupTimer: 0,
            ballSafetyTimer: null,
            audioEnabled: false,
            aimAngle: 0,
            aimPower: 0.5
        };

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const AudioSys = {
            playTone: (freq, type, duration, vol = 0.1) => {
                if(!state.audioEnabled) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            playKick: () => AudioSys.playTone(60, 'triangle', 0.2, 0.4),
            playGoal: () => [0, 0.1, 0.2].forEach((t, i) => setTimeout(() => AudioSys.playTone(400 + (i*100), 'square', 0.4, 0.1), t*1000)),
            playHit: () => AudioSys.playTone(800, 'square', 0.1, 0.1)
        };

        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.Fog(0x1a1a2e, 10, 60);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        const defaultCamPos = new THREE.Vector3(0, 1.4, 3.5); 
        const defaultLookAt = new THREE.Vector3(0, 0.6, -8);
        camera.position.set(0, 2, 7);
        camera.lookAt(0, 0.5, -5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(-10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- ASSETS ---
        const groundGroup = new THREE.Group();
        const grassGeo = new THREE.PlaneGeometry(100, 100);
        const grassMat = new THREE.MeshStandardMaterial({ color: 0x2ecc71, roughness: 1 });
        const baseGround = new THREE.Mesh(grassGeo, grassMat);
        baseGround.rotation.x = -Math.PI / 2;
        baseGround.receiveShadow = true;
        groundGroup.add(baseGround);
        scene.add(groundGroup);

        function createGoal() {
            const goalGroup = new THREE.Group();
            const postMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const postGeo = new THREE.CylinderGeometry(0.15, 0.15, CONFIG.goalHeight);
            const leftPost = new THREE.Mesh(postGeo, postMat); leftPost.position.set(-CONFIG.goalWidth/2, CONFIG.goalHeight/2, 0);
            const rightPost = new THREE.Mesh(postGeo, postMat); rightPost.position.set(CONFIG.goalWidth/2, CONFIG.goalHeight/2, 0);
            const crossBar = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, CONFIG.goalWidth), postMat);
            crossBar.rotation.z = Math.PI / 2; crossBar.position.set(0, CONFIG.goalHeight, 0);
            const net = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.goalWidth, CONFIG.goalHeight, 2), new THREE.MeshBasicMaterial({ color: 0xcccccc, wireframe: true, transparent: true, opacity: 0.2 }));
            net.position.set(0, CONFIG.goalHeight/2, 1);
            goalGroup.add(leftPost, rightPost, crossBar, net);
            goalGroup.position.z = CONFIG.goalZ; 
            scene.add(goalGroup);
        }
        createGoal();

        const keeperGroup = new THREE.Group();
        const keeperBody = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.5, 0.5), new THREE.MeshStandardMaterial({ color: 0xe74c3c }));
        keeperBody.position.y = 1.25; keeperBody.castShadow = true;
        keeperGroup.add(keeperBody);
        keeperGroup.position.set(0, 0, CONFIG.goalZ + 1);
        scene.add(keeperGroup);

        const ballGeo = new THREE.SphereGeometry(0.4, 32, 32);
        const ballMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
        const ball = new THREE.Mesh(ballGeo, ballMat);
        ball.castShadow = true;
        const dot = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({ color: 0x2c3e50 }));
        dot.position.x = 0.35; ball.add(dot);
        scene.add(ball);

        // --- NEW AIMING VISUALS ---
        // Big Arrow on Ground
        const arrowShape = new THREE.Shape();
        arrowShape.moveTo(0, 0);
        arrowShape.lineTo(0.4, -1);
        arrowShape.lineTo(0.15, -1);
        arrowShape.lineTo(0.15, -4);
        arrowShape.lineTo(-0.15, -4);
        arrowShape.lineTo(-0.15, -1);
        arrowShape.lineTo(-0.4, -1);
        arrowShape.lineTo(0, 0);
        const arrowGeo = new THREE.ShapeGeometry(arrowShape);
        const arrowMat = new THREE.MeshBasicMaterial({ color: 0xf1c40f, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
        const aimArrow3D = new THREE.Mesh(arrowGeo, arrowMat);
        aimArrow3D.rotation.x = -Math.PI / 2;
        aimArrow3D.position.y = 0.05;
        scene.add(aimArrow3D);

        const trailGeo = new THREE.BufferGeometry();
        const trailPos = new Float32Array(50 * 3);
        trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
        const trailLine = new THREE.Line(trailGeo, new THREE.LineBasicMaterial({ color: 0x3498db, opacity: 0.8, transparent: true }));
        scene.add(trailLine);

        function updateTrail() {
            if(state.ballState === 'FLYING') {
                const positions = trailLine.geometry.attributes.position.array;
                for(let i = 49; i > 0; i--) {
                    positions[i * 3] = positions[(i - 1) * 3];
                    positions[i * 3 + 1] = positions[(i - 1) * 3 + 1];
                    positions[i * 3 + 2] = positions[(i - 1) * 3 + 2];
                }
                positions[0] = ball.position.x; positions[1] = ball.position.y; positions[2] = ball.position.z;
                trailLine.geometry.attributes.position.needsUpdate = true;
                trailLine.visible = true;
            } else {
                trailLine.visible = false;
            }
        }

        function resetBall() {
            clearTimeout(state.ballSafetyTimer);
            ball.position.set(0, 0.4, -2);
            ball.rotation.set(0,0,0);
            state.velocity.set(0,0,0);
            state.ballState = 'IDLE';
            aimArrow3D.visible = true;
            
            if(state.phase === 'PLAYING') {
                const tween = setInterval(() => {
                    camera.position.lerp(defaultCamPos, 0.05);
                    const targetLook = defaultLookAt.clone();
                    camera.lookAt(targetLook);
                    if(camera.position.distanceTo(defaultCamPos) < 0.1) clearInterval(tween);
                }, 16);
            }
        }
        resetBall();

        // --- NEW ARCADE KICK LOGIC ---
        function updateAiming() {
            if(state.ballState !== 'IDLE' || state.phase !== 'PLAYING') {
                aimArrow3D.visible = false;
                return;
            }
            aimArrow3D.visible = true;

            // 1. Horizontal Aim (Yaw) - Based on Hips Left/Right
            // Hip Center 0.5 is middle. 
            // Range 0.3 (Left) to 0.7 (Right).
            const rawX = state.hipCenter.x;
            const centerOffset = 0.5 - rawX; // Positive = Left, Negative = Right
            state.aimAngle = centerOffset * 2.5; // Multiplier for sensitivity
            
            // 2. Vertical Aim (Power/Loft) - Based on Scale (Distance)
            // Scale 0.2 (Far) -> High Loft (0.9)
            // Scale 0.5 (Close) -> Low Loft (0.2)
            const distFactor = Math.max(0, Math.min(1, (0.5 - state.playerScale) * 3));
            state.aimPower = 0.2 + (distFactor * 0.7);

            // Update Visuals
            aimArrow3D.rotation.z = state.aimAngle;
            aimArrow3D.scale.y = 1 + (state.aimPower * 1.5); // Arrow gets longer with power
            
            // Update UI Bars
            const aimYInd = document.getElementById('aim-y-ind');
            aimYInd.style.top = `${(1 - state.aimPower) * 100}%`;
        }

        function triggerKick(gestureSpeed) {
            if(state.ballState !== 'IDLE') return;
            
            AudioSys.playKick();
            state.ballState = 'FLYING';
            aimArrow3D.visible = false;
            state.ballSafetyTimer = setTimeout(resetBall, 4000);

            // Physics Launch
            const basePower = 15 + (gestureSpeed * 0.2); // Base speed + swing bonus
            const speed = Math.min(basePower, 25);
            
            // Vector Math: Rotate forward vector by aimAngle
            const fwd = new THREE.Vector3(0, 0, -1);
            fwd.applyAxisAngle(new THREE.Vector3(0, 1, 0), state.aimAngle);
            
            const lift = state.aimPower * 0.8; // Height based on distance
            
            state.velocity.set(fwd.x * speed * 0.2, lift, fwd.z * speed * 0.25);
            
            document.getElementById('speed-val').innerText = Math.round(speed * 10);
            document.getElementById('kick-feedback').style.transform = "translate(-50%, -50%) scale(0)";
        }

        function updateBall() {
            if(state.ballState === 'FLYING') {
                state.velocity.y -= 0.025; // Gravity
                state.velocity.z *= 0.995; // Drag
                ball.position.add(state.velocity);
                ball.rotation.x -= state.velocity.z * 0.2; 
                
                // Camera Follow
                const targetLook = new THREE.Vector3(ball.position.x * 0.5, ball.position.y * 0.5 + 1, ball.position.z - 5);
                const currentLook = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).add(camera.position);
                currentLook.lerp(targetLook, 0.05);
                camera.lookAt(currentLook);

                // Floor Bounce
                if(ball.position.y < 0.4) {
                    ball.position.y = 0.4;
                    state.velocity.y *= -0.6;
                }
                
                // Keeper Collision
                if(Math.abs(ball.position.z - keeperGroup.position.z) < 1 && 
                   Math.abs(ball.position.x - keeperGroup.position.x) < 1 &&
                   ball.position.y < 2.5) {
                    state.velocity.z *= -0.5;
                    AudioSys.playHit();
                    showFeedback("SAVED!", "ðŸ§¤");
                }

                // Goal Check
                if(ball.position.z <= CONFIG.goalZ && ball.position.z > CONFIG.goalZ - 2) {
                    if(Math.abs(ball.position.x) < CONFIG.goalWidth/2 && ball.position.y < CONFIG.goalHeight) {
                        scoreGoal();
                    }
                }

                if(ball.position.z < -40 || Math.abs(ball.position.x) > 25) {
                    state.ballState = 'RESETTING';
                    clearTimeout(state.ballSafetyTimer);
                    setTimeout(resetBall, 800);
                }
            } else {
                updateAiming();
            }
        }

        function showFeedback(text, emoji) {
             const fb = document.getElementById('feedback-text');
             fb.innerText = text;
             document.getElementById('aim-arrow-txt').innerText = emoji;
             document.getElementById('kick-feedback').style.transform = "translate(-50%, -50%) scale(1)";
        }

        function scoreGoal() {
            state.score++;
            document.getElementById('score-val').innerText = state.score;
            state.ballState = 'RESETTING';
            clearTimeout(state.ballSafetyTimer);
            AudioSys.playGoal();
            showFeedback("GOAL!!!", "âš½");
            setTimeout(() => {
                document.getElementById('kick-feedback').style.transform = "translate(-50%, -50%) scale(0)";
                resetBall();
            }, 2500);
        }

        function updateKeeper() {
            if(state.ballState === 'FLYING' && ball.position.z < -5) {
                const targetX = Math.max(-CONFIG.goalWidth/2 + 1, Math.min(CONFIG.goalWidth/2 - 1, ball.position.x));
                keeperGroup.position.x += (targetX - keeperGroup.position.x) * 0.15;
            } else {
                keeperGroup.position.x = Math.sin(Date.now() * 0.002) * 3;
            }
        }

        function checkKickGesture(footState) {
            // Simple velocity check: Is foot moving fast?
            const speed = Math.sqrt(footState.vx*footState.vx + footState.vy*footState.vy);
            
            // Check direction: Must be swinging UP or FORWARD (negative Y in screen space usually)
            // We'll mostly rely on raw speed + proximity to bottom of screen (swinging phase)
            if(speed > CONFIG.kickThreshold) {
                triggerKick(speed);
            }
        }

        function updateFootTracking(landmark, footState) {
            if(state.phase !== 'PLAYING') return;
            const scale = Math.max(state.playerScale, 0.1);
            
            const relX = (landmark.x - state.hipCenter.x) / scale * -1.0; 
            const relY = (landmark.y - state.hipCenter.y) / scale; 
            const targetX = relX * 4.0; 
            const targetY = (relY * -4.0) + 2.5; 

            const vx = (targetX - footState.x) * 60;
            const vy = (targetY - footState.y) * 60;

            footState.x = targetX;
            footState.y = targetY;
            footState.vx = vx;
            footState.vy = vy;

            // Trigger Check
            checkKickGesture(footState);
        }

        function startCountdown() {
            state.phase = 'COUNTDOWN';
            const setupMsg = document.getElementById('setup-msg');
            const countTxt = document.getElementById('countdown-txt');
            document.getElementById('guide-reticle').style.display = 'none';
            setupMsg.innerText = "READY!";
            countTxt.style.display = 'block';
            let count = 3;
            countTxt.innerText = count;
            AudioSys.playTone(400, 'sine', 0.1);
            const interval = setInterval(() => {
                count--;
                if(count > 0) {
                    countTxt.innerText = count;
                    AudioSys.playTone(400, 'sine', 0.1);
                } else if(count === 0) {
                    countTxt.innerText = "GO!";
                    AudioSys.playTone(800, 'square', 0.3);
                } else {
                    clearInterval(interval);
                    document.getElementById('setup-overlay').style.display = 'none';
                    state.phase = 'PLAYING';
                    document.getElementById('ui-layer').classList.add('game-active'); 
                    document.getElementById('controls-hint').style.display = 'block';
                    document.getElementById('aim-hud-left').style.display = 'block';
                    const tween = setInterval(() => {
                        camera.position.lerp(defaultCamPos, 0.05);
                        camera.lookAt(defaultLookAt);
                        if(camera.position.distanceTo(defaultCamPos) < 0.1) clearInterval(tween);
                    }, 16);
                }
            }, 1000);
        }

        function checkAutoStart(landmarks) {
            if(state.phase !== 'SETUP') return;
            const shoulderWidth = Math.abs(landmarks[11].x - landmarks[12].x);
            const feetVisible = landmarks[27].visibility > 0.6 && landmarks[28].visibility > 0.6;
            const hipX = (landmarks[23].x + landmarks[24].x) / 2;
            const isCentered = Math.abs(hipX - 0.5) < 0.15; 
            const statusTxt = document.getElementById('guide-status');
            const guide = document.getElementById('guide-reticle');
            
            if(!isCentered) {
                guide.className = 'guide-bad';
                statusTxt.innerText = hipX > 0.5 ? "MOVE LEFT â¬…" : "âž¡ MOVE RIGHT";
                statusTxt.style.color = '#e74c3c';
            } else if (!feetVisible) {
                guide.className = 'guide-bad';
                statusTxt.innerText = "SHOW FEET";
                statusTxt.style.color = '#f1c40f';
            } else {
                guide.className = 'guide-good';
                statusTxt.innerText = "HOLD STILL...";
                statusTxt.style.color = '#2ecc71';
                state.setupTimer++;
                if(state.setupTimer > 50) startCountdown();
            }
        }

        function onResults(results) {
            if (!results.poseLandmarks) return;
            const lm = results.poseLandmarks;
            const shoulderWidth = Math.abs(lm[11].x - lm[12].x);
            state.playerScale = (state.playerScale * 0.95) + (shoulderWidth * 0.05);
            const hipCX = (lm[23].x + lm[24].x) / 2;
            const hipCY = (lm[23].y + lm[24].y) / 2;
            state.hipCenter.x = (state.hipCenter.x * 0.9) + (hipCX * 0.1);
            state.hipCenter.y = (state.hipCenter.y * 0.9) + (hipCY * 0.1);

            if(state.phase === 'SETUP') {
                checkAutoStart(lm);
            } else if(state.phase === 'PLAYING') {
                updateFootTracking(lm[27], state.leftFoot);
                updateFootTracking(lm[28], state.rightFoot);
            }
        }

        const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
        pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        pose.onResults(onResults);

        const videoElement = document.getElementById('input-video');
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await pose.send({image: videoElement}); },
            width: 640, height: 480
        });

        const startBtn = document.getElementById('start-btn');
        startBtn.addEventListener('click', () => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            state.audioEnabled = true;
            cameraUtils.start().then(() => {
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('setup-overlay').style.display = 'block';
                document.getElementById('guide-reticle').style.display = 'block'; 
                state.phase = 'SETUP';
            });
            startBtn.innerText = "Starting...";
        });

        setTimeout(() => { startBtn.disabled = false; startBtn.innerText = "PLAY"; }, 1000);

        function animate() {
            requestAnimationFrame(animate);
            updateBall();
            updateKeeper();
            updateTrail();
            renderer.render(scene, camera);
        }
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
