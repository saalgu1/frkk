
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>AR Free Kick - Pro Mode</title>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Teko:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0; overflow: hidden;
            background-color: #1a1a2e;
            font-family: 'Teko', sans-serif;
            user-select: none; -webkit-user-select: none;
        }

        #game-container {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1;
        }

        #input-video {
            position: absolute; top: 0; left: 0; width: 320px; height: 240px;
            transform: scaleX(-1); opacity: 0; pointer-events: none; z-index: 0;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .hud-top {
            padding: 20px; display: flex; justify-content: space-between; color: white; text-transform: uppercase;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8); width: 100%; box-sizing: border-box;
        }

        .score-box {
            background: rgba(0,0,0,0.6); padding: 10px 25px; border-radius: 8px;
            border-left: 5px solid #f1c40f; font-size: 32px; letter-spacing: 2px;
        }

        .center-card {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95); padding: 40px; border-radius: 12px;
            text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.6);
            pointer-events: auto; width: 90%; max-width: 420px;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .hidden { opacity: 0; pointer-events: none; }

        h1 { margin: 0; color: #2c3e50; font-size: 56px; line-height: 0.9; }
        p { font-family: sans-serif; color: #7f8c8d; margin-bottom: 24px; font-size: 16px; line-height: 1.5; }

        button {
            background: #e74c3c; color: white; border: none; padding: 16px 40px; border-radius: 30px;
            font-size: 28px; font-family: 'Teko', sans-serif;
            cursor: pointer; text-transform: uppercase; letter-spacing: 2px; width: 100%;
        }
        button:disabled { background: #bdc3c7; cursor: wait; }

        #setup-overlay {
            position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: white; text-shadow: 0 2px 10px rgba(0,0,0,1);
            display: none; width: 100%; z-index: 50;
        }
        #setup-msg { font-size: 50px; color: #f1c40f; font-weight: 600; white-space: nowrap; }
        #countdown-txt { font-size: 150px; font-weight: bold; display: none; color: white; }

        #kick-feedback {
            position: absolute; top: 40%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 90px; color: #fff;
            text-shadow: 0 0 20px #f1c40f, 4px 4px 0 #c0392b;
            transition: transform 0.2s;
            pointer-events: none; white-space: nowrap; text-align: center; z-index: 20;
        }

        #guide-reticle {
            position: absolute; top: 50%; left: 50%;
            width: 320px; height: 500px;
            transform: translate(-50%, -45%);
            border: 4px dashed rgba(255,255,255,0.3); border-radius: 20px;
            box-sizing: border-box; pointer-events: none;
            display: none;
        }
        #guide-status {
            position: absolute; bottom: -50px; width: 100%; 
            text-align: center; font-size: 30px; color: white;
            text-shadow: 0 2px 4px black; font-weight: bold;
        }
        
        #debug-feet {
            position: absolute; bottom: 10px; left: 10px;
            color: rgba(255,255,255,0.5); font-family: monospace;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <video id="input-video" playsinline></video>
    <div id="game-container"></div>
    
    <div id="kick-feedback">GOAL!!!</div>
    
    <div id="guide-reticle">
        <div id="guide-status">Adjusting...</div>
    </div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-box">GOALS: <span id="score-val">0</span></div>
            <div class="score-box" style="border-left:none; border-right: 5px solid #3498db">
                SPEED: <span id="speed-val">0</span> km/h
            </div>
        </div>

        <div id="start-screen" class="center-card">
            <h1>FREE KICK PRO</h1>
            <p>1. <strong>Step Left/Right</strong> to Aim Arrow<br>2. <strong>Watch Your Feet</strong> (Glowing Balls)<br>3. <strong>Kick</strong> the Ball on Screen!</p>
            <button id="start-btn" disabled>Loading Engine...</button>
        </div>

        <div id="setup-overlay">
            <div id="setup-msg"></div>
            <div id="countdown-txt">3</div>
        </div>
        
        <div id="debug-feet">Waiting for feet...</div>
    </div>

    <script>
        /**
         * FREE KICK PRO - PHYSICS UPDATE
         * Fixes: Ghost Kicks, Foot Visibility, Right-Foot Bias
         */

        const CONFIG = {
            kickThreshold: 2.0, // Reduced slightly, but added distance check
            contactDist: 0.8,   // Foot must be this close to ball to kick
            goalWidth: 14,
            goalHeight: 7,
            goalZ: -24,
        };

        let state = {
            phase: 'MENU', 
            score: 0,
            ballState: 'IDLE',
            velocity: new THREE.Vector3(),
            leftFoot: {x: 0, y: 0, vx: 0, vy: 0},
            rightFoot: {x: 0, y: 0, vx: 0, vy: 0},
            playerScale: 1.0, 
            hipCenter: {x: 0.5, y: 0.5},
            setupTimer: 0,
            ballSafetyTimer: null,
            aimAngle: 0,
            aimPower: 0.5
        };

        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.Fog(0x1a1a2e, 10, 60);

        // Camera setup - zoomed in for "Pro Mode" feel
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        const defaultCamPos = new THREE.Vector3(0, 1.6, 4.0); 
        const defaultLookAt = new THREE.Vector3(0, 0.5, -6);
        camera.position.set(0, 2, 8);
        camera.lookAt(0, 0.5, -5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(-10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Ground
        const grassGeo = new THREE.PlaneGeometry(100, 100);
        const grassMat = new THREE.MeshStandardMaterial({ color: 0x2ecc71, roughness: 1 });
        const ground = new THREE.Mesh(grassGeo, grassMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Goal
        function createGoal() {
            const goalGroup = new THREE.Group();
            const postMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const postGeo = new THREE.CylinderGeometry(0.15, 0.15, CONFIG.goalHeight);
            
            const leftPost = new THREE.Mesh(postGeo, postMat); leftPost.position.set(-CONFIG.goalWidth/2, CONFIG.goalHeight/2, 0);
            const rightPost = new THREE.Mesh(postGeo, postMat); rightPost.position.set(CONFIG.goalWidth/2, CONFIG.goalHeight/2, 0);
            const crossBar = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, CONFIG.goalWidth), postMat);
            crossBar.rotation.z = Math.PI / 2; crossBar.position.set(0, CONFIG.goalHeight, 0);
            
            const net = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.goalWidth, CONFIG.goalHeight, 2), new THREE.MeshBasicMaterial({ color: 0xcccccc, wireframe: true, transparent: true, opacity: 0.1 }));
            net.position.set(0, CONFIG.goalHeight/2, 1);
            
            goalGroup.add(leftPost, rightPost, crossBar, net);
            goalGroup.position.z = CONFIG.goalZ; 
            scene.add(goalGroup);
        }
        createGoal();

        // The Wall (Defenders)
        const wallGroup = new THREE.Group();
        for(let i=-1; i<=1; i++) {
            const dummy = new THREE.Mesh(new THREE.BoxGeometry(1, 2.8, 0.5), new THREE.MeshStandardMaterial({ color: 0xe74c3c }));
            dummy.position.set(i * 1.5, 1.4, 0);
            dummy.castShadow = true;
            wallGroup.add(dummy);
        }
        wallGroup.position.z = -12;
        wallGroup.position.x = -2; // Start slightly left covering near post
        scene.add(wallGroup);

        // Goalkeeper
        const keeperMesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.5, 0.5), new THREE.MeshStandardMaterial({ color: 0xf39c12 }));
        keeperMesh.position.set(0, 1.25, CONFIG.goalZ + 1);
        keeperMesh.castShadow = true;
        scene.add(keeperMesh);

        // Ball
        const ballGeo = new THREE.SphereGeometry(0.4, 32, 32);
        const ballMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const ball = new THREE.Mesh(ballGeo, ballMat);
        ball.castShadow = true;
        scene.add(ball);

        // Aim Arrow
        const arrowShape = new THREE.Shape();
        arrowShape.moveTo(0, 0); arrowShape.lineTo(0.5, -1); arrowShape.lineTo(0.2, -1); arrowShape.lineTo(0.2, -4); arrowShape.lineTo(-0.2, -4); arrowShape.lineTo(-0.2, -1); arrowShape.lineTo(-0.5, -1); arrowShape.lineTo(0, 0);
        const arrowMesh = new THREE.Mesh(new THREE.ShapeGeometry(arrowShape), new THREE.MeshBasicMaterial({ color: 0xf1c40f, transparent: true, opacity: 0.6, side: THREE.DoubleSide }));
        arrowMesh.rotation.x = -Math.PI / 2;
        arrowMesh.position.y = 0.05;
        scene.add(arrowMesh);

        // FOOT TRACKERS (Visual Debug)
        const footGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const leftFootMesh = new THREE.Mesh(footGeo, new THREE.MeshBasicMaterial({ color: 0x3498db, transparent: true, opacity: 0.7, depthTest: false }));
        const rightFootMesh = new THREE.Mesh(footGeo, new THREE.MeshBasicMaterial({ color: 0xe74c3c, transparent: true, opacity: 0.7, depthTest: false }));
        // Important: renderOrder ensures they appear ON TOP of the grass/ball so user can see them
        leftFootMesh.renderOrder = 999;
        rightFootMesh.renderOrder = 999;
        scene.add(leftFootMesh);
        scene.add(rightFootMesh);

        // Audio System (Synthesized)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;
            if (type === 'KICK') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(80, now); osc.frequency.exponentialRampToValueAtTime(10, now + 0.1);
                gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'GOAL') {
                osc.type = 'square'; osc.frequency.setValueAtTime(400, now);
                osc.frequency.setValueAtTime(600, now+0.1); osc.frequency.setValueAtTime(800, now+0.2);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+1);
                osc.start(now); osc.stop(now+1);
            }
        }

        // --- GAME LOGIC ---

        function resetBall() {
            clearTimeout(state.ballSafetyTimer);
            ball.position.set(0, 0.4, -2);
            ball.rotation.set(0,0,0);
            state.velocity.set(0,0,0);
            state.ballState = 'IDLE';
            arrowMesh.visible = true;
            leftFootMesh.visible = true;
            rightFootMesh.visible = true;
            
            // Randomize wall position slightly
            wallGroup.position.x = (Math.random() * 6) - 3;
            
            if(state.phase === 'PLAYING') {
                const tween = setInterval(() => {
                    camera.position.lerp(defaultCamPos, 0.1);
                    camera.lookAt(defaultLookAt);
                    if(camera.position.distanceTo(defaultCamPos) < 0.1) clearInterval(tween);
                }, 16);
            }
        }
        resetBall();

        function updateAiming() {
            if(state.ballState !== 'IDLE' || state.phase !== 'PLAYING') {
                arrowMesh.visible = false; return;
            }
            arrowMesh.visible = true;

            // Hip Center 0.5 is middle. User moves Left (< 0.5) to aim Right.
            // Right-foot bias: shift neutral zone to 0.45
            const rawX = state.hipCenter.x;
            const centerOffset = 0.45 - rawX; 
            state.aimAngle = centerOffset * 3.0;
            
            arrowMesh.rotation.z = state.aimAngle;
        }

        function triggerKick(speed, footX) {
            playSound('KICK');
            state.ballState = 'FLYING';
            state.ballSafetyTimer = setTimeout(resetBall, 3500);

            // Calculate Power & Direction
            const power = Math.min(speed, 25);
            // Curve depends on where foot hit ball relative to center
            const impactOffset = (footX - ball.position.x) * 2.0; 
            
            const fwd = new THREE.Vector3(0, 0, -1);
            fwd.applyAxisAngle(new THREE.Vector3(0, 1, 0), state.aimAngle);
            
            // Apply Physics
            state.velocity.set(
                fwd.x * power * 0.25 - (impactOffset * 0.1), // Add slight curve based on impact
                0.2 + (power * 0.05), // Lift
                fwd.z * power * 0.25
            );
            
            document.getElementById('speed-val').innerText = Math.round(power * 10);
            document.getElementById('kick-feedback').style.transform = "translate(-50%, -50%) scale(0)";
        }

        function updateBall() {
            if(state.ballState === 'FLYING') {
                state.velocity.y -= 0.025; // Gravity
                state.velocity.z *= 0.99; // Air resistance
                ball.position.add(state.velocity);
                ball.rotation.x -= 0.1;

                // Follow Camera
                const targetPos = new THREE.Vector3(ball.position.x * 0.3, ball.position.y * 0.5 + 2, ball.position.z + 6);
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(ball.position);

                // Bounce
                if(ball.position.y < 0.4) {
                    ball.position.y = 0.4;
                    state.velocity.y *= -0.6;
                }

                // Collisions (Wall)
                if(ball.position.z < wallGroup.position.z + 0.5 && ball.position.z > wallGroup.position.z - 0.5) {
                    if(Math.abs(ball.position.x - wallGroup.position.x) < 2.5 && ball.position.y < 3) {
                        state.velocity.z *= -0.5;
                        state.velocity.y += 0.2;
                        showFeedback("BLOCKED!");
                    }
                }

                // Collisions (Keeper)
                if(ball.position.z < keeperMesh.position.z + 0.5 && ball.position.z > keeperMesh.position.z - 0.5) {
                    if(Math.abs(ball.position.x - keeperMesh.position.x) < 1.0 && ball.position.y < 2.5) {
                        state.velocity.z *= -0.5;
                        showFeedback("SAVED!");
                    }
                }

                // Goal
                if(ball.position.z < CONFIG.goalZ && ball.position.z > CONFIG.goalZ - 2) {
                    if(Math.abs(ball.position.x) < CONFIG.goalWidth/2 && ball.position.y < CONFIG.goalHeight) {
                        scoreGoal();
                    }
                }
                
                // Miss
                if(ball.position.z < -35 && state.ballState === 'FLYING') {
                     state.ballState = 'RESETTING';
                     showFeedback("MISSED");
                     setTimeout(resetBall, 1000);
                }

            } else {
                updateAiming();
            }
        }

        function showFeedback(txt) {
            const el = document.getElementById('kick-feedback');
            el.innerText = txt;
            el.style.transform = "translate(-50%, -50%) scale(1)";
        }

        function scoreGoal() {
            state.score++;
            document.getElementById('score-val').innerText = state.score;
            playSound('GOAL');
            state.ballState = 'RESETTING';
            clearTimeout(state.ballSafetyTimer);
            showFeedback("GOAL!!!!");
            setTimeout(() => {
                document.getElementById('kick-feedback').style.transform = "translate(-50%, -50%) scale(0)";
                resetBall();
            }, 2000);
        }

        function updateKeeper() {
            // Simple AI: Follow ball x
            if(state.ballState === 'FLYING' && ball.position.z < -10) {
                 keeperMesh.position.x += (ball.position.x - keeperMesh.position.x) * 0.1;
            } else {
                keeperMesh.position.x = Math.sin(Date.now()*0.003) * 2; 
            }
        }

        function updateFootTracking(landmark, footState, mesh) {
            if(state.phase !== 'PLAYING') return;
            const scale = Math.max(state.playerScale, 0.1);
            
            // Map 2D landmarks to 3D world space
            // NOTE: We invert X because selfie camera is mirrored
            const relX = (landmark.x - state.hipCenter.x) / scale * -1.0; 
            const relY = (landmark.y - state.hipCenter.y) / scale; 
            
            // Tuned Mapping
            const targetX = relX * 3.5; 
            const targetY = (relY * -3.5) + 2.0; 

            // Physics Smoothing
            const vx = (targetX - footState.x) * 40;
            const vy = (targetY - footState.y) * 40;
            const speed = Math.sqrt(vx*vx + vy*vy);

            footState.x += (targetX - footState.x) * 0.5;
            footState.y += (targetY - footState.y) * 0.5;
            footState.vx = vx;
            footState.vy = vy;

            // Visual Update
            mesh.position.set(footState.x, footState.y, -1.8); // Place slightly in front of ball (-2.0)

            // KICK DETECTION LOGIC
            // 1. Distance Check: Is foot visually close to ball?
            const dx = Math.abs(footState.x - ball.position.x);
            const dy = Math.abs(footState.y - ball.position.y);
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            // 2. Velocity Check: Is foot moving fast?
            // 3. Direction Check: Must be swinging (y < 1.0 ensures we are low)
            if(dist < CONFIG.contactDist && speed > CONFIG.kickThreshold && footState.y < 1.0) {
                // Flash foot white
                mesh.material.color.setHex(0xffffff);
                setTimeout(() => mesh.material.color.setHex(0xe74c3c), 100);
                triggerKick(speed, footState.x);
            }
            
            // Debug text
            if(speed > 1) {
                document.getElementById('debug-feet').innerText = `Speed: ${speed.toFixed(1)} | Dist: ${dist.toFixed(2)}`;
            }
        }

        function startCountdown() {
            state.phase = 'COUNTDOWN';
            document.getElementById('setup-msg').innerText = "READY!";
            document.getElementById('countdown-txt').style.display = 'block';
            document.getElementById('guide-reticle').style.display = 'none';
            
            let count = 3;
            const interval = setInterval(() => {
                document.getElementById('countdown-txt').innerText = count;
                count--;
                if(count < 0) {
                    clearInterval(interval);
                    document.getElementById('setup-overlay').style.display = 'none';
                    state.phase = 'PLAYING';
                    // Enable camera motion
                    const tween = setInterval(() => {
                        camera.position.lerp(defaultCamPos, 0.05);
                        camera.lookAt(defaultLookAt);
                        if(camera.position.distanceTo(defaultCamPos) < 0.1) clearInterval(tween);
                    }, 16);
                }
            }, 1000);
        }

        function checkAutoStart(landmarks) {
            if(state.phase !== 'SETUP') return;
            const shoulderWidth = Math.abs(landmarks[11].x - landmarks[12].x);
            const feetVisible = landmarks[27].visibility > 0.6 && landmarks[28].visibility > 0.6;
            
            const guide = document.getElementById('guide-reticle');
            const status = document.getElementById('guide-status');
            
            // Simple validation: Feet must be visible and player relatively centered
            if(feetVisible && shoulderWidth < 0.5) {
                guide.style.borderColor = "#2ecc71";
                status.innerText = "HOLD STILL...";
                state.setupTimer++;
                if(state.setupTimer > 60) startCountdown();
            } else {
                state.setupTimer = 0;
                guide.style.borderColor = "#e74c3c";
                status.innerText = !feetVisible ? "SHOW FEET" : "STEP BACK";
            }
        }

        function onResults(results) {
            if (!results.poseLandmarks) return;
            const lm = results.poseLandmarks;
            
            // Update Scale & Center
            const shoulderWidth = Math.abs(lm[11].x - lm[12].x);
            state.playerScale = (state.playerScale * 0.95) + (shoulderWidth * 0.05);
            const hipCX = (lm[23].x + lm[24].x) / 2;
            const hipCY = (lm[23].y + lm[24].y) / 2;
            state.hipCenter.x = (state.hipCenter.x * 0.9) + (hipCX * 0.1);
            state.hipCenter.y = (state.hipCenter.y * 0.9) + (hipCY * 0.1);

            if(state.phase === 'SETUP') {
                checkAutoStart(lm);
            } else if(state.phase === 'PLAYING') {
                updateFootTracking(lm[27], state.leftFoot, leftFootMesh);
                updateFootTracking(lm[28], state.rightFoot, rightFootMesh);
            }
        }

        const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
        pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        pose.onResults(onResults);

        const videoElement = document.getElementById('input-video');
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await pose.send({image: videoElement}); },
            width: 640, height: 480
        });

        const startBtn = document.getElementById('start-btn');
        startBtn.addEventListener('click', () => {
            cameraUtils.start().then(() => {
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('setup-overlay').style.display = 'block';
                document.getElementById('guide-reticle').style.display = 'block';
                state.phase = 'SETUP';
            });
            startBtn.innerText = "Starting...";
        });

        setTimeout(() => { startBtn.disabled = false; startBtn.innerText = "PLAY"; }, 1000);

        function animate() {
            requestAnimationFrame(animate);
            updateBall();
            updateKeeper();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
    
