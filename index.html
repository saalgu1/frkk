<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>AR Free Kick - Body Aim Edition</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Teko:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0; overflow: hidden;
            background-color: #1a1a2e;
            font-family: 'Teko', sans-serif;
            user-select: none; -webkit-user-select: none;
        }

        #game-container {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1;
        }

        #input-video {
            position: absolute; top: 0; left: 0; width: 320px; height: 240px;
            transform: scaleX(-1); opacity: 0; pointer-events: none; z-index: 0;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            transition: all 0.5s;
        }

        #ui-layer.game-active .hud-top {
            transform: scale(1.4);
            transform-origin: top center;
            margin-top: 10px;
        }

        .hud-top {
            padding: 20px; display: flex; justify-content: space-between; color: white; text-transform: uppercase;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
            transition: transform 0.5s;
            width: 100%; box-sizing: border-box;
        }

        .score-box {
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(0,0,0,0.4)); 
            padding: 10px 25px;
            border-radius: 8px;
            border-left: 5px solid #2ecc71; font-size: 32px; letter-spacing: 2px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .power-meter-container {
            width: 220px; height: 24px; background: rgba(0,0,0,0.6);
            margin-top: 8px; border: 2px solid rgba(255,255,255,0.3); border-radius: 12px; overflow: hidden;
            display: none; 
        }
        .power-bar {
            height: 100%; width: 0%; background: linear-gradient(90deg, #f1c40f, #e74c3c); transition: width 0.1s;
        }

        .center-card {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95); padding: 40px; border-radius: 12px;
            text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.6);
            pointer-events: auto; width: 90%; max-width: 420px;
            transition: opacity 0.3s;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .hidden { opacity: 0; pointer-events: none; }

        h1 { margin: 0; color: #2c3e50; font-size: 56px; line-height: 0.9; letter-spacing: 1px; }
        p { font-family: sans-serif; color: #7f8c8d; margin-bottom: 24px; font-size: 16px; line-height: 1.5; }

        button {
            background: linear-gradient(to right, #e74c3c, #c0392b); 
            color: white; border: none; padding: 16px 40px; border-radius: 30px;
            font-size: 28px; font-family: 'Teko', sans-serif;
            cursor: pointer; text-transform: uppercase; letter-spacing: 2px; width: 100%;
            transition: transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 10px 20px rgba(231, 76, 60, 0.3);
        }
        button:active { transform: scale(0.98); }
        button:disabled { background: #bdc3c7; cursor: wait; box-shadow: none; }

        #setup-overlay {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: white; text-shadow: 0 2px 20px rgba(0,0,0,0.8);
            display: none; width: 100%; z-index: 50;
        }
        #setup-msg { font-size: 60px; color: #f1c40f; font-weight: 600; white-space: nowrap; }
        #countdown-txt { font-size: 200px; font-weight: bold; display: none; margin-top: -20px; color: white;}

        #guide-reticle {
            position: absolute; top: 50%; left: 50%;
            width: 300px; height: 550px;
            transform: translate(-50%, -45%);
            border: 8px dashed #00ffff;
            border-radius: 30px;
            box-sizing: border-box;
            pointer-events: none;
            display: none;
            transition: all 0.3s;
            z-index: 40;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }
        #guide-reticle::before {
            content: "FRAME YOUR BODY";
            position: absolute; top: -60px; width: 140%; left: -20%; text-align: center;
            color: #00ffff; font-size: 42px; text-shadow: 0 2px 4px black;
            background: rgba(0,0,0,0.7); padding: 5px; border-radius: 5px;
        }
        #guide-status {
            position: absolute; bottom: 20px; width: 100%; 
            text-align: center; font-size: 48px; color: white;
            text-shadow: 0 2px 10px black; font-weight: bold;
        }

        .guide-bad { border-color: #e74c3c !important; box-shadow: 0 0 20px rgba(231, 76, 60, 0.5) !important; }
        .guide-good { border-color: #2ecc71 !important; box-shadow: 0 0 50px rgba(46, 204, 113, 0.8) !important; background: rgba(46,204,113,0.1); }
        
        #warning-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(231, 76, 60, 0.95); color: white; padding: 30px 60px;
            font-size: 50px; border-radius: 20px; display: none; text-align: center;
            border: 4px solid white; z-index: 60; box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            white-space: nowrap;
        }

        #kick-feedback {
            position: absolute; top: 30%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 110px; color: #fff;
            text-shadow: 0 0 20px #f1c40f, 6px 6px 0 #c0392b;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none; white-space: nowrap; text-align: center;
            z-index: 20;
        }
        #aim-arrow { font-size: 60px; display: block; margin-top: 5px; color: #f1c40f; text-shadow: 2px 2px 0 #000; }

        #technique-label {
            position: absolute; bottom: 20%; left: 50%; transform: translate(-50%, 0);
            font-size: 30px; color: #00ffff; text-shadow: 0 0 10px #00ffff;
            opacity: 0; transition: opacity 0.5s;
        }

        #debug-info {
            position: absolute; bottom: 10px; left: 10px;
            color: rgba(255,255,255,0.3); font-family: monospace; font-size: 10px;
            text-align: left;
        }

        #game-container::after {
            content: " ";
            display: block; position: absolute; top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 4px; z-index: 2; pointer-events: none;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <video id="input-video" playsinline></video>
    <div id="game-container"></div>
    
    <div id="kick-feedback">
        <span id="feedback-text">GOAL!!!</span>
        <div id="aim-arrow"></div>
    </div>
    
    <div id="technique-label">TARGET LOCKED</div>
    <div id="warning-msg">OFF SCREEN</div>
    
    <div id="guide-reticle">
        <div id="guide-status">Adjusting...</div>
    </div>

    <div id="ui-layer">
        <div class="hud-top">
            <div>
                <div class="score-box">GOALS: <span id="score-val">0</span></div>
                <div class="power-meter-container" id="p-meter-cont">
                    <div class="power-bar" id="p-bar"></div>
                </div>
            </div>
            <div class="score-box" style="border-left:none; border-right: 5px solid #3498db">
                SPEED: <span id="speed-val">0</span> km/h
            </div>
        </div>

        <div id="start-screen" class="center-card">
            <h1>FREE KICK PRO</h1>
            <p style="font-size: 60px; margin: 10px;">⚽</p>
            <p><strong>BODY CONTROLS:</strong><br>Move Left/Right to AIM<br>Move Back for HEIGHT<br>Move Forward for LOW<br><strong>SWING FOOT TO KICK</strong></p>
            <button id="start-btn" disabled>Loading Engine...</button>
        </div>

        <div id="setup-overlay">
            <div id="setup-msg"></div>
            <div id="countdown-txt">3</div>
        </div>
        
        <div id="debug-info">System Ready</div>
    </div>

    <script>
        /**
         * FREE KICK PRO - BODY CONTROL EDITION
         * Move body to aim, Swing foot to trigger.
         */

        const CONFIG = {
            kickThreshold: 2.0, 
            goalWidth: 14,
            goalHeight: 7,
            goalZ: -24,
            minScale: 0.25,
            wallZ: -14,
        };

        let state = {
            phase: 'MENU', 
            score: 0,
            ballState: 'IDLE',
            velocity: new THREE.Vector3(),
            aimTarget: new THREE.Vector3(0, 0, CONFIG.goalZ), // Stores current aim
            leftFoot: {x: 0, y: 0, vx: 0, vy: 0},
            rightFoot: {x: 0, y: 0, vx: 0, vy: 0},
            playerScale: 1.0, 
            hipCenter: {x: 0.5, y: 0.5},
            setupTimer: 0,
            ballSafetyTimer: null,
            audioEnabled: false,
            outOfBounds: false
        };

        // --- AUDIO SYSTEM ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const AudioSys = {
            playTone: (freq, type, duration, vol = 0.1) => {
                if(!state.audioEnabled) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            playKick: (type) => {
                const pitch = type === 'power' ? 60 : 120;
                AudioSys.playTone(pitch, 'triangle', 0.2, 0.4);
            },
            playGoal: () => {
                [0, 0.1, 0.2].forEach((t, i) => setTimeout(() => AudioSys.playTone(400 + (i*100), 'square', 0.4, 0.1), t*1000));
            },
            playHit: () => {
                AudioSys.playTone(800, 'square', 0.1, 0.1);
            }
        };

        // --- Three.js Setup ---
        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.Fog(0x1a1a2e, 10, 60);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        const defaultCamPos = new THREE.Vector3(0, 1.4, 3.5); 
        const defaultLookAt = new THREE.Vector3(0, 0.6, -8);
        const setupCamPos = new THREE.Vector3(0, 2, 7);
        
        camera.position.copy(setupCamPos);
        camera.lookAt(0, 0.5, -5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(-10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- ASSETS ---
        function createStadiumLight(x, z) {
            const poleGeo = new THREE.CylinderGeometry(0.2, 0.2, 15);
            const poleMat = new THREE.MeshLambertMaterial({color: 0x555555});
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.set(x, 7.5, z);
            scene.add(pole);
            const headGeo = new THREE.BoxGeometry(2, 1, 1);
            const headMat = new THREE.MeshBasicMaterial({color: 0xffffee});
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.set(x, 15, z);
            head.lookAt(0,0,CONFIG.goalZ);
            scene.add(head);
        }
        createStadiumLight(-15, -5);
        createStadiumLight(15, -5);
        createStadiumLight(-15, -30);
        createStadiumLight(15, -30);

        const groundGroup = new THREE.Group();
        const grassGeo = new THREE.PlaneGeometry(100, 100);
        const grassMat1 = new THREE.MeshStandardMaterial({ color: 0x2ecc71, roughness: 1 });
        const grassMat2 = new THREE.MeshStandardMaterial({ color: 0x27ae60, roughness: 1 });
        const baseGround = new THREE.Mesh(grassGeo, grassMat1);
        baseGround.rotation.x = -Math.PI / 2;
        baseGround.receiveShadow = true;
        groundGroup.add(baseGround);
        for(let i=0; i<20; i++) {
            const stripe = new THREE.Mesh(new THREE.PlaneGeometry(100, 5), grassMat2);
            stripe.rotation.x = -Math.PI / 2;
            stripe.position.y = 0.01;
            stripe.position.z = -50 + (i * 10);
            stripe.receiveShadow = true;
            groundGroup.add(stripe);
        }
        scene.add(groundGroup);

        function createGoal() {
            const goalGroup = new THREE.Group();
            const postMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });
            const postGeo = new THREE.CylinderGeometry(0.15, 0.15, CONFIG.goalHeight);
            const leftPost = new THREE.Mesh(postGeo, postMat);
            leftPost.position.set(-CONFIG.goalWidth/2, CONFIG.goalHeight/2, 0);
            leftPost.castShadow = true;
            const rightPost = new THREE.Mesh(postGeo, postMat);
            rightPost.position.set(CONFIG.goalWidth/2, CONFIG.goalHeight/2, 0);
            rightPost.castShadow = true;
            const crossBarGeo = new THREE.CylinderGeometry(0.15, 0.15, CONFIG.goalWidth);
            const crossBar = new THREE.Mesh(crossBarGeo, postMat);
            crossBar.rotation.z = Math.PI / 2;
            crossBar.position.set(0, CONFIG.goalHeight, 0);
            crossBar.castShadow = true;
            const netGeo = new THREE.BoxGeometry(CONFIG.goalWidth, CONFIG.goalHeight, 2);
            const netMat = new THREE.MeshBasicMaterial({ color: 0xcccccc, wireframe: true, transparent: true, opacity: 0.2 });
            const net = new THREE.Mesh(netGeo, netMat);
            net.position.set(0, CONFIG.goalHeight/2, 1);
            goalGroup.add(leftPost, rightPost, crossBar, net);
            goalGroup.position.z = CONFIG.goalZ; 
            scene.add(goalGroup);
            return goalGroup;
        }
        const goal = createGoal();

        const keeperGroup = new THREE.Group();
        const keeperBodyGeo = new THREE.BoxGeometry(1.2, 2.5, 0.5);
        const keeperMat = new THREE.MeshStandardMaterial({ color: 0xe74c3c });
        const keeperBody = new THREE.Mesh(keeperBodyGeo, keeperMat);
        keeperBody.position.y = 1.25;
        keeperBody.castShadow = true;
        keeperGroup.add(keeperBody);
        const armGeo = new THREE.BoxGeometry(0.3, 1.2, 0.3);
        const leftArm = new THREE.Mesh(armGeo, keeperMat); leftArm.position.set(-0.8, 1.8, 0); leftArm.rotation.z = 0.5;
        const rightArm = new THREE.Mesh(armGeo, keeperMat); rightArm.position.set(0.8, 1.8, 0); rightArm.rotation.z = -0.5;
        keeperGroup.add(leftArm, rightArm);
        keeperGroup.position.set(0, 0, CONFIG.goalZ + 1);
        scene.add(keeperGroup);

        const wallGroup = new THREE.Group();
        const dummyGeo = new THREE.CylinderGeometry(0.4, 0.4, 1.8, 16);
        const dummyMat = new THREE.MeshStandardMaterial({ color: 0x34495e });
        [-0.8, 0, 0.8].forEach(x => {
            const dummy = new THREE.Mesh(dummyGeo, dummyMat);
            dummy.position.set(x, 0.9, 0);
            dummy.castShadow = true;
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshStandardMaterial({color: 0xf1c40f}));
            head.position.y = 1.1;
            dummy.add(head);
            wallGroup.add(dummy);
        });
        wallGroup.position.set(-2, 0, CONFIG.wallZ);
        scene.add(wallGroup);

        const ballGeo = new THREE.SphereGeometry(0.4, 32, 32);
        const ballMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
        const ball = new THREE.Mesh(ballGeo, ballMat);
        ball.castShadow = true;
        scene.add(ball);

        const ringGeo = new THREE.RingGeometry(0.5, 0.6, 32);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xf1c40f, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
        const kickZone = new THREE.Mesh(ringGeo, ringMat);
        kickZone.rotation.x = -Math.PI / 2;
        kickZone.position.set(0, 0.05, -2);
        scene.add(kickZone);

        const zoneGeo = new THREE.RingGeometry(0.8, 1.0, 32);
        const zoneMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
        const playerZone = new THREE.Mesh(zoneGeo, zoneMat);
        playerZone.rotation.x = -Math.PI / 2;
        playerZone.position.set(0, 0.02, -1.0); 
        scene.add(playerZone);

        // Aiming Visuals
        const aimStickGeo = new THREE.CylinderGeometry(0.04, 0.04, 1, 8); 
        const aimStickMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
        const aimStick = new THREE.Mesh(aimStickGeo, aimStickMat);
        aimStick.geometry.rotateX(-Math.PI / 2); 
        aimStick.geometry.translate(0, 0, 0.5); 
        scene.add(aimStick);
        aimStick.visible = false;

        const ghostBallGeo = new THREE.SphereGeometry(0.2, 16, 16);
        const ghostBallMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5, wireframe: true });
        const ghostBall = new THREE.Mesh(ghostBallGeo, ghostBallMat);
        scene.add(ghostBall);
        ghostBall.visible = false;

        const trailSize = 50;
        const trailGeo = new THREE.BufferGeometry();
        const trailPos = new Float32Array(trailSize * 3);
        trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
        const trailMat = new THREE.LineBasicMaterial({ color: 0x3498db, opacity: 0.8, transparent: true, linewidth: 3 });
        const trailLine = new THREE.Line(trailGeo, trailMat);
        scene.add(trailLine);
        trailLine.frustumCulled = false;

        function updateTrail() {
            if(state.ballState === 'FLYING') {
                const positions = trailLine.geometry.attributes.position.array;
                for(let i = trailSize - 1; i > 0; i--) {
                    positions[i * 3] = positions[(i - 1) * 3];
                    positions[i * 3 + 1] = positions[(i - 1) * 3 + 1];
                    positions[i * 3 + 2] = positions[(i - 1) * 3 + 2];
                }
                positions[0] = ball.position.x;
                positions[1] = ball.position.y;
                positions[2] = ball.position.z;
                trailLine.geometry.attributes.position.needsUpdate = true;
                trailLine.visible = true;
            } else {
                trailLine.visible = false;
            }
        }

        const particleCount = 100;
        const particlesGeo = new THREE.BufferGeometry();
        const pPos = new Float32Array(particleCount * 3);
        const pVel = [];
        const pCols = new Float32Array(particleCount * 3);
        for(let i=0; i<particleCount; i++) {
            pVel.push({x:0, y:0, z:0, active: false});
            const c = new THREE.Color().setHSL(Math.random(), 1.0, 0.5);
            pCols[i*3] = c.r; pCols[i*3+1] = c.g; pCols[i*3+2] = c.b;
        }
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        particlesGeo.setAttribute('color', new THREE.BufferAttribute(pCols, 3));
        const particlesMat = new THREE.PointsMaterial({ size: 0.3, vertexColors: true, transparent: true });
        const particleSystem = new THREE.Points(particlesGeo, particlesMat);
        scene.add(particleSystem);
        
        function explodeParticles(x, y, z) {
            const positions = particleSystem.geometry.attributes.position.array;
            for(let i=0; i<particleCount; i++) {
                positions[i*3] = x;
                positions[i*3+1] = y;
                positions[i*3+2] = z;
                pVel[i].x = (Math.random() - 0.5) * 0.5;
                pVel[i].y = (Math.random() * 0.5) + 0.2;
                pVel[i].z = (Math.random() - 0.5) * 0.5;
                pVel[i].active = true;
            }
            particleSystem.visible = true;
        }

        function updateParticles() {
            if(!particleSystem.visible) return;
            const positions = particleSystem.geometry.attributes.position.array;
            let activeCount = 0;
            for(let i=0; i<particleCount; i++) {
                if(pVel[i].active) {
                    activeCount++;
                    pVel[i].y -= 0.01;
                    positions[i*3] += pVel[i].x;
                    positions[i*3+1] += pVel[i].y;
                    positions[i*3+2] += pVel[i].z;
                    if(positions[i*3+1] < 0) pVel[i].active = false;
                }
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
            if(activeCount === 0) particleSystem.visible = false;
        }
        particleSystem.visible = false;

        // --- FOOT VISUALS ---
        function createFootModel(color) {
            const group = new THREE.Group();
            const ankle = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshBasicMaterial({ color: color, wireframe: true, transparent: true, opacity: 0.6 }));
            const footBody = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.1, 0.4), new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.4 }));
            footBody.position.z = 0.1; 
            group.add(ankle); group.add(footBody);
            return group;
        }
        
        const leftFootMesh = createFootModel(0xe74c3c);
        const rightFootMesh = createFootModel(0x3498db);
        scene.add(leftFootMesh); scene.add(rightFootMesh);
        leftFootMesh.visible = false; rightFootMesh.visible = false;

        function resetBall() {
            clearTimeout(state.ballSafetyTimer);
            ball.position.set(0, 0.4, -2);
            ball.rotation.set(0,0,0);
            state.velocity.set(0,0,0);
            state.ballState = 'IDLE';
            document.getElementById('p-meter-cont').style.display = 'none';
            document.getElementById('technique-label').style.opacity = '0';
            kickZone.material.opacity = 0.6;
            kickZone.scale.set(1,1,1);
            wallGroup.position.x = (Math.random() * 4) - 2;
            
            if(state.phase === 'PLAYING') {
                const tween = setInterval(() => {
                    camera.position.lerp(defaultCamPos, 0.05);
                    const currentLookAt = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).add(camera.position);
                    const targetLook = defaultLookAt.clone();
                    currentLookAt.lerp(targetLook, 0.05);
                    camera.lookAt(targetLook);
                    if(camera.position.distanceTo(defaultCamPos) < 0.1) clearInterval(tween);
                }, 16);
            }
        }
        resetBall();

        // --- NEW KICK LOGIC ---
        function triggerKick(footSpeed) {
            if(state.ballState !== 'IDLE' || state.outOfBounds) return;
            
            // 1. Calculate Direction Vector: (Target - Ball)
            const direction = new THREE.Vector3().subVectors(state.aimTarget, ball.position).normalize();
            
            // 2. Determine Power
            const power = Math.min(footSpeed, 25); 
            const speedMultiplier = power * 1.2; 

            // 3. Apply Velocity
            state.velocity.copy(direction).multiplyScalar(speedMultiplier);
            state.velocity.x += (Math.random() - 0.5) * 0.1; // Tiny randomization

            // UI Updates
            AudioSys.playKick('power');
            state.ballState = 'FLYING';
            kickZone.material.opacity = 0; 
            aimStick.visible = false;
            ghostBall.visible = false;

            const techLabel = document.getElementById('technique-label');
            techLabel.innerText = "SHOT FIRED!";
            techLabel.style.opacity = '1';

            state.ballSafetyTimer = setTimeout(resetBall, 4000);
            
            // Update Scoreboard speed
            const speedKm = Math.round(power * 10); 
            document.getElementById('speed-val').innerText = speedKm;
            const bar = document.getElementById('p-bar');
            document.getElementById('p-meter-cont').style.display = 'block';
            bar.style.width = Math.min((speedKm / 120) * 100, 100) + "%";
            document.getElementById('kick-feedback').style.transform = "translate(-50%, -50%) scale(0)";
        }

        // --- NEW AIMING LOGIC ---
        function updateAiming() {
            if(state.phase !== 'PLAYING' || state.ballState !== 'IDLE') {
                aimStick.visible = false;
                ghostBall.visible = false;
                return;
            }

            // 1. HORIZONTAL AIMING (Body Left/Right)
            // MediaPipe X is 0 (Left) to 1 (Right). 
            // Inverted for mirror effect: Left on screen = Left Aim.
            const aimX = (state.hipCenter.x - 0.5) * 35; 

            // 2. VERTICAL AIMING (Body Distance)
            // state.playerScale is roughly 0.2 (Far) to 0.7 (Close).
            const maxScale = 0.6; 
            const minScale = 0.2; 
            let heightFactor = (maxScale - state.playerScale) / (maxScale - minScale);
            heightFactor = Math.max(0, Math.min(1, heightFactor)); 
            
            const aimY = heightFactor * (CONFIG.goalHeight - 1); 

            state.aimTarget.set(aimX, aimY, CONFIG.goalZ);

            // Visuals
            aimStick.position.copy(ball.position);
            aimStick.lookAt(state.aimTarget); 
            const length = ball.position.distanceTo(state.aimTarget);
            aimStick.scale.set(1, 1, length); 
            aimStick.visible = true;

            ghostBall.position.copy(state.aimTarget);
            ghostBall.visible = true;
            
            // Color code: Green = Goal, Red = Post/Miss
            if(Math.abs(aimX) < CONFIG.goalWidth/2 && aimY < CONFIG.goalHeight) {
                ghostBall.material.color.setHex(0x00ff00);
            } else {
                ghostBall.material.color.setHex(0xff0000);
            }
        }

        function updateBall() {
            if(state.ballState === 'FLYING') {
                state.velocity.y -= 0.025; // Gravity
                state.velocity.z *= 0.995; // Drag
                const prevPos = ball.position.clone();
                ball.position.add(state.velocity);
                ball.rotation.x -= state.velocity.z * 0.2; 
                ball.rotation.z -= state.velocity.x * 0.2; 
                
                // Camera Follow
                const targetLook = new THREE.Vector3(
                    ball.position.x * 0.3, 
                    Math.max(0, ball.position.y * 0.4 + 1.0), 
                    ball.position.z * 0.8 - 5
                );
                const currentLook = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).add(camera.position);
                currentLook.lerp(targetLook, 0.05);
                camera.lookAt(currentLook);

                // Ground bounce
                if(ball.position.y < 0.4) {
                    ball.position.y = 0.4;
                    state.velocity.y *= -0.6;
                    state.velocity.z *= 0.8;
                }
                
                // Wall Hit
                if(ball.position.z < (CONFIG.wallZ + 0.5) && ball.position.z > (CONFIG.wallZ - 0.5)) {
                    const distToWallCenter = Math.abs(ball.position.x - wallGroup.position.x);
                    if(distToWallCenter < 1.5 && ball.position.y < 2.0) {
                        state.velocity.z *= -0.5;
                        state.velocity.y += 0.2;
                        AudioSys.playHit();
                        showFeedback("BLOCKED!", "");
                    }
                }
                
                // Keeper Save
                const kx = keeperGroup.position.x;
                const ky = keeperGroup.position.y;
                const kz = keeperGroup.position.z;
                const dx = Math.abs(ball.position.x - kx);
                const dy = Math.abs(ball.position.y - ky);
                const dz = Math.abs(ball.position.z - kz);
                if(dz < 0.8 && dx < 1.0 && dy < 1.5) {
                    state.velocity.z *= -0.5;
                    state.velocity.x += (Math.random()-0.5);
                    AudioSys.playHit();
                    showFeedback("SAVED!", "");
                }
                
                // Goal Scoring
                if(prevPos.z >= CONFIG.goalZ && ball.position.z <= CONFIG.goalZ) {
                    if(Math.abs(ball.position.x) < CONFIG.goalWidth/2 && ball.position.y < CONFIG.goalHeight) {
                        scoreGoal();
                    }
                }
                
                // Reset conditions
                if(ball.position.z < -40 || Math.abs(ball.position.x) > 25) {
                    state.ballState = 'RESETTING';
                    clearTimeout(state.ballSafetyTimer);
                    setTimeout(resetBall, 800);
                }
            } else {
                // Idle animation
                const s = 1 + Math.sin(Date.now() * 0.005) * 0.1;
                kickZone.scale.set(s, s, 1);
            }
        }

        function showFeedback(text, subtext) {
             const fb = document.getElementById('feedback-text');
             fb.innerText = text;
             document.getElementById('aim-arrow').innerText = subtext;
             document.getElementById('kick-feedback').style.transform = "translate(-50%, -50%) scale(1)";
        }

        function scoreGoal() {
            state.score++;
            document.getElementById('score-val').innerText = state.score;
            state.ballState = 'RESETTING';
            clearTimeout(state.ballSafetyTimer);
            AudioSys.playGoal();
            explodeParticles(ball.position.x, ball.position.y, ball.position.z);
            showFeedback("GOAL!!!", "⚽");
            setTimeout(() => {
                document.getElementById('kick-feedback').style.transform = "translate(-50%, -50%) scale(0)";
                resetBall();
            }, 2500);
        }

        function updateKeeper() {
            if(state.ballState === 'FLYING') {
                if(ball.position.z < -5) {
                    const targetX = Math.max(-CONFIG.goalWidth/2 + 1, Math.min(CONFIG.goalWidth/2 - 1, ball.position.x));
                    keeperGroup.position.x += (targetX - keeperGroup.position.x) * 0.15;
                    if(ball.position.y > 2 && keeperGroup.position.y < 2) {
                         keeperGroup.position.y += 0.2;
                    }
                }
            } else {
                keeperGroup.position.x = Math.sin(Date.now() * 0.002) * 3;
                keeperGroup.position.y = 0;
            }
        }

        // --- SIMPLIFIED FOOT TRACKING ---
        function updateFootTracking(ankle, toe, footState, mesh) {
            if(state.phase !== 'PLAYING') return;
            const scale = Math.max(state.playerScale, CONFIG.minScale);
            
            // Map foot position
            const relX = (ankle.x - state.hipCenter.x) / scale * -1.0; 
            const relY = (ankle.y - state.hipCenter.y) / scale; 
            const targetX = relX * 4.0; 
            const targetY = (relY * -4.0) + 2.5; 

            // Smooth movement
            const newX = footState.x + (targetX - footState.x) * 0.5;
            const newY = footState.y + (targetY - footState.y) * 0.5;
            
            // Calculate Velocity
            const vx = (newX - footState.x) * 60;
            const vy = (newY - footState.y) * 60;
            const speed = Math.sqrt(vx*vx + vy*vy);

            footState.x = newX;
            footState.y = newY;
            
            // Update Visual Mesh
            mesh.position.set(newX, newY, -1.5);
            
            // TRIGGER KICK
            if(ankle.visibility > 0.6) {
                const distToBall = Math.sqrt(Math.pow(newX - ball.position.x, 2) + Math.pow(newY - ball.position.y, 2));
                // If foot is close and moving fast
                if(distToBall < 0.6 && speed > CONFIG.kickThreshold && newY < 0.8) {
                    triggerKick(speed);
                }
            }
        }

        function startCountdown() {
            state.phase = 'COUNTDOWN';
            const setupMsg = document.getElementById('setup-msg');
            const countTxt = document.getElementById('countdown-txt');
            document.getElementById('guide-reticle').style.display = 'none';
            setupMsg.innerText = "READY!";
            countTxt.style.display = 'block';
            let count = 3;
            countTxt.innerText = count;
            AudioSys.playTone(400, 'sine', 0.1);
            const interval = setInterval(() => {
                count--;
                if(count > 0) {
                    countTxt.innerText = count;
                    AudioSys.playTone(400, 'sine', 0.1);
                } else if(count === 0) {
                    countTxt.innerText = "GO!";
                    AudioSys.playTone(800, 'square', 0.3);
                } else {
                    clearInterval(interval);
                    document.getElementById('setup-overlay').style.display = 'none';
                    state.phase = 'PLAYING';
                    document.getElementById('ui-layer').classList.add('game-active'); 
                    const tween = setInterval(() => {
                        camera.position.lerp(defaultCamPos, 0.05);
                        camera.lookAt(defaultLookAt);
                        if(camera.position.distanceTo(defaultCamPos) < 0.1) clearInterval(tween);
                    }, 16);
                    leftFootMesh.visible = true;
                    rightFootMesh.visible = true;
                }
            }, 1000);
        }

        function checkPlayerPosition(landmarks) {
            // Only warn if they are almost completely off screen
            const hipX = (landmarks[23].x + landmarks[24].x) / 2;
            if (hipX < 0.05 || hipX > 0.95) {
                document.getElementById('warning-msg').style.display = 'block';
                state.outOfBounds = true;
            } else {
                document.getElementById('warning-msg').style.display = 'none';
                state.outOfBounds = false;
            }
        }

        function checkAutoStart(landmarks) {
            if(state.phase !== 'SETUP') return;
            const shoulderWidth = Math.abs(landmarks[11].x - landmarks[12].x);
            const feetVisible = landmarks[27].visibility > 0.6 && landmarks[28].visibility > 0.6;
            const playerIsFar = shoulderWidth < 0.45 && shoulderWidth > 0.15; 
            const hipX = (landmarks[23].x + landmarks[24].x) / 2;
            const isCentered = Math.abs(hipX - 0.5) < 0.15; 
            const guide = document.getElementById('guide-reticle');
            const statusTxt = document.getElementById('guide-status');
            
            if(!isCentered) {
                guide.className = 'guide-bad';
                statusTxt.innerText = hipX > 0.5 ? "MOVE LEFT ⬅" : "➡ MOVE RIGHT";
                statusTxt.style.color = '#e74c3c';
            } else if (!playerIsFar) {
                guide.className = 'guide-bad';
                statusTxt.innerText = shoulderWidth >= 0.45 ? "MOVE BACK ⬇" : "COME CLOSER ⬆";
                statusTxt.style.color = '#f1c40f';
            } else if (!feetVisible) {
                guide.className = 'guide-bad';
                statusTxt.innerText = "SHOW FEET";
                statusTxt.style.color = '#f1c40f';
            } else {
                guide.className = 'guide-good';
                statusTxt.innerText = "HOLD STILL...";
                statusTxt.style.color = '#2ecc71';
            }

            if(feetVisible && playerIsFar && isCentered) {
                state.setupTimer++;
                if(state.setupTimer > 50) startCountdown();
            } else {
                state.setupTimer = 0;
            }
        }

        function onResults(results) {
            if (!results.poseLandmarks) return;
            const lm = results.poseLandmarks;
            const shoulderWidth = Math.abs(lm[11].x - lm[12].x);
            state.playerScale = (state.playerScale * 0.95) + (shoulderWidth * 0.05);
            const hipCX = (lm[23].x + lm[24].x) / 2;
            const hipCY = (lm[23].y + lm[24].y) / 2;
            state.hipCenter.x = (state.hipCenter.x * 0.9) + (hipCX * 0.1);
            state.hipCenter.y = (state.hipCenter.y * 0.9) + (hipCY * 0.1);

            document.getElementById('debug-info').innerText = `State: ${state.phase} | Scale: ${state.playerScale.toFixed(2)}`;

            if(state.phase === 'SETUP') {
                checkAutoStart(lm);
            } else if(state.phase === 'PLAYING') {
                checkPlayerPosition(lm);
                updateFootTracking(lm[27], lm[31], state.leftFoot, leftFootMesh);
                updateFootTracking(lm[28], lm[32], state.rightFoot, rightFootMesh);
            }
        }

        const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true, 
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        pose.onResults(onResults);

        const videoElement = document.getElementById('input-video');
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await pose.send({image: videoElement}); },
            width: 640, height: 480
        });

        const startBtn = document.getElementById('start-btn');
        startBtn.addEventListener('click', () => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            state.audioEnabled = true;
            cameraUtils.start().then(() => {
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('setup-overlay').style.display = 'block';
                document.getElementById('guide-reticle').style.display = 'block'; 
                state.phase = 'SETUP';
            });
            startBtn.innerText = "Starting...";
        });

        setTimeout(() => {
            startBtn.disabled = false;
            startBtn.innerText = "PLAY";
        }, 1000);

        function animate() {
            requestAnimationFrame(animate);
            updateBall();
            updateKeeper();
            updateTrail();
            updateParticles();
            updateAiming();
            renderer.render(scene, camera);
        }
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
